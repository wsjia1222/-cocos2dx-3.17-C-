# 卡牌游戏程序设计文档

## 一、项目概述

这是一个基于cocos2d-x引擎开发的卡牌游戏项目。游戏采用MVC（Model-View-Controller）架构设计，代码结构清晰，易于维护和扩展。

### 游戏规则
- 玩家可以点击主牌区的卡牌与底牌堆的顶部卡牌进行匹配
- 匹配规则：两张卡牌的点数差1即可匹配（无花色要求）
- 玩家可以点击底牌堆的备用底牌来替换顶部底牌
- 支持回退功能，可以撤销上一步操作

## 二、代码架构

### 2.1 目录结构

```
Classes/
├── AppDelegate.h/cpp          # 应用程序入口，初始化游戏引擎
├── GameScene.h/cpp            # 游戏场景，连接视图和控制器
├── HelloWorldScene.h/cpp       # 模板场景（未使用）
├── controllers/               # 控制器层（Controller）
│   └── GameController.h/cpp   # 游戏控制器，处理游戏逻辑
├── models/                     # 数据模型层（Model）
│   ├── CardModel.h            # 卡牌数据模型
│   ├── GameModel.h/cpp        # 游戏数据模型
│   └── UndoModel.h            # 回退数据模型
├── views/                      # 视图层（View）
│   ├── GameView.h/cpp         # 游戏主视图
│   ├── CardView.h/cpp         # 单张卡牌视图
│   ├── PlayfieldView.h/cpp    # 主牌区视图
│   └── StackView.h/cpp        # 底牌堆视图
└── managers/                   # 管理器层
    └── UndoManager.h/cpp       # 回退管理器
```

### 2.2 MVC架构说明

#### Model（模型层）
- **CardModel**: 存储单张卡牌的数据（ID、点数、花色、位置等）
- **GameModel**: 管理整个游戏的数据状态（主牌区卡牌、底牌堆卡牌）
- **UndoModel**: 定义回退操作的数据结构

#### View（视图层）
- **GameView**: 游戏主视图，包含主牌区和底牌堆
- **CardView**: 单张卡牌的UI显示
- **PlayfieldView**: 主牌区的容器视图
- **StackView**: 底牌堆的容器视图

#### Controller（控制器层）
- **GameController**: 处理用户输入，协调Model和View

#### Manager（管理器层）
- **UndoManager**: 管理回退操作的栈

### 2.3 数据流向

```
用户点击卡牌
    ↓
CardView触发点击事件
    ↓
GameController.onCardClicked()
    ↓
判断操作类型（匹配/换底牌）
    ↓
更新GameModel（数据层）
    ↓
记录UndoRecord到UndoManager
    ↓
更新GameView（视图层）
```

## 三、核心类说明

### 3.1 GameController（游戏控制器）

**职责**：
- 处理用户输入（卡牌点击、回退按钮点击）
- 管理游戏逻辑（卡牌匹配、换底牌）
- 协调Model和View的更新

**关键方法**：
- `startGame()`: 初始化游戏，创建初始卡牌
- `onCardClicked(int cardId)`: 处理卡牌点击事件
- `onUndoClicked()`: 处理回退按钮点击
- `canMatch(int card1Face, int card2Face)`: 检查两张卡牌是否可以匹配
- `updateView()`: 根据模型数据更新视图

### 3.2 GameModel（游戏数据模型）

**职责**：
- 存储所有卡牌的数据
- 管理卡牌ID的分配
- 提供卡牌的增删查改方法

**关键数据结构**：
- `playfieldCards`: 主牌区的卡牌列表（vector）
- `stackCards`: 底牌堆的卡牌列表（vector），最后一张是顶部卡牌
- `nextCardId`: 卡牌ID计数器

### 3.3 UndoManager（回退管理器）

**职责**：
- 使用栈（stack）存储所有操作记录
- 提供回退功能

**关键方法**：
- `push(const UndoRecord& record)`: 记录一次操作
- `undo()`: 执行一次回退，返回操作记录
- `canUndo()`: 检查是否可以回退

### 3.4 CardView（卡牌视图）

**职责**：
- 显示单张卡牌的UI（底图、数字、花色）
- 处理卡牌点击事件
- 播放卡牌移动动画

## 四、如何添加新卡牌

### 4.1 在GameController::startGame()中添加

在`GameController::startGame()`方法中，按照以下步骤添加新卡牌：

```cpp
// 1. 创建CardModel对象
CardModel newCard;
newCard.id = _gameModel.getNextCardId();  // 获取新的唯一ID
newCard.face = 5;   // 设置点数（1=A, 2-10=数字, 11=J, 12=Q, 13=K）
newCard.suit = 2;   // 设置花色（0=梅花, 1=方块, 2=红桃, 3=黑桃）
newCard.isFaceUp = true;  // 是否正面朝上
newCard.posX = 400;  // X坐标
newCard.posY = 900;  // Y坐标

// 2. 添加到主牌区或底牌堆
_gameModel.addCardToPlayfield(newCard);  // 添加到主牌区
// 或
_gameModel.addCardToStack(newCard);     // 添加到底牌堆
```

### 4.2 注意事项

1. **ID分配**：必须使用`_gameModel.getNextCardId()`获取唯一ID，不要手动设置
2. **位置设置**：确保卡牌位置在屏幕可见范围内
3. **底牌堆顺序**：底牌堆的卡牌顺序很重要，最后添加的卡牌会成为顶部卡牌
4. **更新视图**：添加卡牌后，调用`updateView()`更新视图显示

### 4.3 示例：添加一张新卡牌到主牌区

```cpp
// 在GameController::startGame()方法中，主牌区卡牌创建部分添加：

// 第七张卡牌：红桃K
CardModel card7;
card7.id = _gameModel.getNextCardId();
card7.face = 13;   // K（King，王）
card7.suit = 2;    // 红桃（Heart，♥）
card7.isFaceUp = true;
card7.posX = 400;  // 新位置
card7.posY = 700;  // 新位置
_gameModel.addCardToPlayfield(card7);
```

## 五、如何添加新类型的回退功能

### 5.1 扩展MoveType枚举

在`models/UndoModel.h`中，添加新的操作类型：

```cpp
enum class MoveType {
    STACK_REPLACE,      // 手牌区翻牌替换（已有）
    PLAYFIELD_MATCH,    // 桌面牌匹配（已有）
    NEW_OPERATION_TYPE  // 新操作类型（新增）
};
```

### 5.2 扩展UndoRecord结构体

如果需要存储额外的回退信息，在`models/UndoModel.h`的`UndoRecord`结构体中添加字段：

```cpp
struct UndoRecord {
    // ... 现有字段 ...
    
    // 新操作类型需要的额外信息
    int newField1;      // 新字段1
    std::string newField2;  // 新字段2（如果需要）
};
```

### 5.3 在操作时记录回退信息

在`GameController`中执行新操作时，创建`UndoRecord`并记录：

```cpp
// 执行新操作
void GameController::handleNewOperation(int cardId) {
    // ... 执行操作的逻辑 ...
    
    // 记录回退信息
    UndoRecord record;
    record.cardId = cardId;
    record.moveType = MoveType::NEW_OPERATION_TYPE;  // 新操作类型
    record.originalPos = Vec2(x, y);  // 原始位置
    record.originalParent = 0;  // 原始区域
    record.newField1 = someValue;  // 新字段的值
    
    // 保存到回退管理器
    _undoManager.push(record);
}
```

### 5.4 在回退时处理新操作类型

在`GameController::onUndoClicked()`方法中，添加新操作类型的回退逻辑：

```cpp
void GameController::onUndoClicked() {
    if (!_undoManager.canUndo()) {
        return;
    }
    
    UndoRecord record = _undoManager.undo();
    
    // ... 现有的回退逻辑 ...
    
    // 添加新操作类型的回退处理
    else if (record.moveType == MoveType::NEW_OPERATION_TYPE) {
        // 1. 恢复卡牌位置
        CardView* cardView = /* 找到卡牌视图 */;
        cardView->playMoveAnimation(record.originalPos, [this]() {
            // 2. 恢复游戏模型状态
            // ... 恢复逻辑 ...
            
            // 3. 更新视图
            updateView();
        });
    }
}
```

### 5.5 完整示例：添加"卡牌翻转"回退功能

假设我们要添加一个"卡牌翻转"功能（将卡牌从正面翻到背面），并支持回退：

#### 步骤1：扩展MoveType
```cpp
enum class MoveType {
    STACK_REPLACE,
    PLAYFIELD_MATCH,
    CARD_FLIP  // 新增：卡牌翻转
};
```

#### 步骤2：扩展UndoRecord（如果需要）
```cpp
struct UndoRecord {
    // ... 现有字段 ...
    bool originalFaceUp;  // 记录原始的正反面状态
};
```

#### 步骤3：实现翻转操作
```cpp
void GameController::handleCardFlip(int cardId) {
    // 找到卡牌
    CardModel card = _gameModel.getCardById(cardId);
    if (card.id == -1) return;
    
    // 记录回退信息
    UndoRecord record;
    record.cardId = cardId;
    record.moveType = MoveType::CARD_FLIP;
    record.originalFaceUp = card.isFaceUp;  // 记录原始状态
    
    // 执行翻转
    card.isFaceUp = !card.isFaceUp;
    _gameModel.updateCard(card);  // 更新模型（需要实现这个方法）
    
    // 记录回退
    _undoManager.push(record);
    
    // 更新视图
    updateView();
}
```

#### 步骤4：实现回退逻辑
```cpp
void GameController::onUndoClicked() {
    // ... 现有代码 ...
    
    else if (record.moveType == MoveType::CARD_FLIP) {
        // 找到卡牌
        CardModel card = _gameModel.getCardById(record.cardId);
        if (card.id != -1) {
            // 恢复原始状态
            card.isFaceUp = record.originalFaceUp;
            _gameModel.updateCard(card);
            
            // 更新视图
            updateView();
        }
    }
}
```

## 六、代码设计原则

### 6.1 单一职责原则
- 每个类只负责一个功能
- Model只管理数据，View只负责显示，Controller只处理逻辑

### 6.2 依赖倒置原则
- Controller依赖View的接口，而不是具体实现
- 使用回调函数实现解耦

### 6.3 开闭原则
- 对扩展开放：可以轻松添加新卡牌、新操作类型
- 对修改封闭：添加新功能不需要修改现有代码的核心逻辑


## 七、总结

本项目采用清晰的MVC架构，代码结构合理，易于理解和扩展。通过遵循本文档的指导，可以轻松添加新卡牌和新类型的回退功能。建议在修改代码前先理解整体架构，然后按照文档步骤进行扩展。

